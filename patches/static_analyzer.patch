--- /home/mobsf/Mobile-Security-Framework-MobSF/mobsf/StaticAnalyzer/views/android/static_analyzer.py	2024-10-10 16:49:38.606995190 +0300
+++ /home/mobsf/Mobile-Security-Framework-MobSF/mobsf/StaticAnalyzer/views/android/static_analyzer.py	2024-10-10 17:33:52.442201239 +0300
@@ -613,3 +613,400 @@
         full_path = os.path.join(inside, x)
         shutil.move(full_path, app_dir)
     shutil.rmtree(inside)
+
+@login_required
+def static_analyzer_apk_unpack(request, checksum, api=False):
+    """Do static analysis on a request and save to db."""
+    try:
+        rescan = False
+        if api:
+            re_scan = request.POST.get('re_scan', 0)
+        else:
+            re_scan = request.GET.get('rescan', 0)
+        if re_scan == '1':
+            rescan = True
+        
+        # Create a new app_dic and initialize its structure
+        app_dic = {}
+        if not is_md5(checksum):
+            return print_n_send_error_response(
+                request,
+                'Invalid Hash',
+                api)
+
+        robj = RecentScansDB.objects.filter(MD5=checksum)
+        if not robj.exists():
+            return print_n_send_error_response(
+                request,
+                'The file is not uploaded/available',
+                api)
+
+        typ = robj[0].SCAN_TYPE
+        filename = robj[0].FILE_NAME
+        allowed_exts = tuple(f'.{i}' for i in settings.ANDROID_EXTS)
+        if (not filename.lower().endswith(allowed_exts)
+                or typ not in settings.ANDROID_EXTS):
+            return print_n_send_error_response(
+                request,
+                'Invalid file extension or file type',
+                api)
+
+        # Initialize the structure of app_dic
+        app_dic['dir'] = Path(settings.BASE_DIR)
+        app_dic['app_name'] = filename
+        app_dic['md5'] = checksum
+        app_dic['app_dir'] = Path(settings.UPLD_DIR) / checksum
+        app_dic['tools_dir'] = app_dic['dir'] / 'StaticAnalyzer' / 'tools'
+        app_dic['tools_dir'] = app_dic['tools_dir'].as_posix()
+        app_dic['icon_path'] = ''
+
+        # Save app_dic to a file after initialization
+        save_app_dic_to_file(app_dic, checksum)
+
+        # Log the start of analysis
+        msg = f'Scan Hash: {checksum}'
+        logger.info(msg)
+
+        msg = f'Starting Analysis on: {app_dic["app_name"]}'
+        logger.info(msg)
+
+        # Handle different file types
+        if typ == 'xapk':
+            if not handle_xapk(app_dic):
+                raise Exception('Invalid XAPK File')
+            typ = 'apk'
+        elif typ == 'apks':
+            if not handle_split_apk(app_dic):
+                raise Exception('Invalid Split APK File')
+            typ = 'apk'
+        elif typ == 'aab':
+            if not handle_aab(app_dic):
+                raise Exception('Invalid AAB File')
+            typ = 'apk'
+
+        if typ == 'apk':
+            # Preparation for analysis
+            app_dic['app_file'] = f'{checksum}.apk'
+            app_dic['app_path'] = (app_dic['app_dir'] / app_dic['app_file']).as_posix()
+            app_dic['app_dir'] = app_dic['app_dir'].as_posix() + '/'
+
+            save_app_dic_to_file(app_dic, checksum)  # Update the app_dic file
+
+            # APK extraction
+            msg = 'Extracting APK'
+            logger.info(msg)
+            append_scan_status(checksum, 'init')
+            app_dic['files'] = unzip(
+                checksum,
+                app_dic['app_path'],
+                app_dic['app_dir'])
+            logger.info('APK Extracted')
+
+            save_app_dic_to_file(app_dic, checksum)  # Update the app_dic file
+
+            if not app_dic['files']:
+                msg = 'APK file is invalid or corrupt'
+                append_scan_status(checksum, msg)
+                return print_n_send_error_response(
+                    request,
+                    msg,
+                    api)
+
+            app_dic['certz'] = get_hardcoded_cert_keystore(
+                checksum,
+                app_dic['files'])
+
+            mani_file, ns, mani_xml = get_manifest(
+                checksum,
+                app_dic['app_path'],
+                app_dic['app_dir'],
+                app_dic['tools_dir'],
+                'apk',
+            )
+            app_dic['manifest_file'] = mani_file
+            app_dic['parsed_xml'] = mani_xml
+
+            save_app_dic_to_file(app_dic, checksum)  # Update the app_dic file
+
+            apk = parse_apk(
+                checksum,
+                app_dic['app_path'])
+
+            app_dic['real_name'] = get_app_name(
+                apk,
+                app_dic['app_dir'],
+                True,
+            )
+
+            man_data_dic = manifest_data(
+                checksum,
+                app_dic['parsed_xml'],
+                ns)
+
+            app_name = app_dic['real_name']
+            pkg_name = man_data_dic['packagename']
+            if app_name or pkg_name:
+                if app_name and pkg_name:
+                    subject = f'{app_name} ({pkg_name})'
+                elif app_name:
+                    subject = app_name
+                elif pkg_name:
+                    subject = pkg_name
+                msg = f'Performing Static Analysis on: {subject}'
+                logger.info(msg)
+                append_scan_status(checksum, msg)
+
+            app_dic['playstore'] = get_app_details(
+                checksum,
+                man_data_dic['packagename'])
+
+            save_app_dic_to_file(app_dic, checksum)  # Update the app_dic file
+
+            # Convert DEX to Smali
+            apk_2_java(
+                checksum,
+                app_dic['app_path'],
+                app_dic['app_dir'],
+                app_dic['tools_dir'])
+
+            dex_2_smali(
+                checksum,
+                app_dic['app_dir'],
+                app_dic['tools_dir'])
+
+            save_app_dic_to_file(app_dic, checksum)  # Update the app_dic file
+
+            # Log the successful completion
+            logger.info(f'Successful completion of static analysis for: {app_dic["app_name"]}')
+            
+            if api:
+                return {'status': 'success'}
+            else:
+                return HttpResponse("Analysis Completed")
+
+        else:
+            return print_n_send_error_response(
+                request,
+                'Unsupported file type',
+                api)
+
+    except Exception as e:
+        logger.error(f'Error during static analysis: {e}')
+        return print_n_send_error_response(request, str(e), api)
+
+@login_required
+def static_analyzer_apk_analyze(request, checksum, api=False):
+    """Do static analysis on a request and save to db."""
+    try:
+        rescan = False
+        if api:
+            re_scan = request.POST.get('re_scan', 0)
+        else:
+            re_scan = request.GET.get('rescan', 0)
+        if re_scan == '1':
+            rescan = True
+
+        # Load app_dic from file
+        app_dic = load_app_dic_from_file(checksum)
+        if not app_dic:
+            return print_n_send_error_response(
+                request,
+                'The app_dic file is not available or corrupt',
+                api)
+
+        # Validate the checksum
+        if not is_md5(checksum):
+            return print_n_send_error_response(
+                request,
+                'Invalid Hash',
+                api)
+
+        # Check for the presence of a record in the database
+        robj = RecentScansDB.objects.filter(MD5=checksum)
+        if not robj.exists():
+            return print_n_send_error_response(
+                request,
+                'The file is not uploaded/available',
+                api)
+
+        typ = robj[0].SCAN_TYPE
+        if typ != 'apk':
+            return print_n_send_error_response(
+                request,
+                'Only APK files are supported now!',
+                api)
+
+        # Use the existing app_dic
+        app_dic['app_file'] = f'{checksum}.apk'
+        app_dic['app_path'] = os.path.join(app_dic['app_dir'], app_dic['app_file'])
+        app_dic['app_dir'] = app_dic['app_dir'] + '/'  # Already a string
+
+        # Check for a database record
+        db_entry = StaticAnalyzerAndroid.objects.filter(MD5=checksum)
+        if db_entry.exists() and not rescan:
+            context = get_context_from_db_entry(db_entry)
+        else:
+            if not has_permission(request, Permissions.SCAN, api):
+                return print_n_send_error_response(
+                    request,
+                    'Permission Denied',
+                    False)
+
+            # Analysis begins
+            append_scan_status(checksum, 'init')
+            app_dic['size'] = str(file_size(app_dic['app_path'])) + 'MB'
+            app_dic['sha1'], app_dic['sha256'] = hash_gen(checksum, app_dic['app_path'])
+
+            msg = 'Starting Static Analysis'
+            logger.info(msg)
+            append_scan_status(checksum, msg)
+
+            # Manifest XML
+            mani_file, ns, mani_xml = get_manifest(
+                checksum,
+                app_dic['app_path'],
+                app_dic['app_dir'],
+                app_dic['tools_dir'],
+                'apk',
+            )
+            app_dic['manifest_file'] = mani_file
+            app_dic['parsed_xml'] = mani_xml
+
+            # Update the app_dic file after obtaining the manifest
+            save_app_dic_to_file(app_dic, checksum)
+
+            # APK analysis using Androguard
+            apk = parse_apk(checksum, app_dic['app_path'])
+            app_dic['real_name'] = get_app_name(apk, app_dic['app_dir'], True)
+
+            man_data_dic = manifest_data(checksum, app_dic['parsed_xml'], ns)
+
+            app_name = app_dic['real_name']
+            pkg_name = man_data_dic['packagename']
+            if app_name or pkg_name:
+                if app_name and pkg_name:
+                    subject = f'{app_name} ({pkg_name})'
+                elif app_name:
+                    subject = app_name
+                elif pkg_name:
+                    subject = pkg_name
+                msg = f'Performing Static Analysis on: {subject}'
+                logger.info(msg)
+                append_scan_status(checksum, msg)
+
+            man_an_dic = manifest_analysis(
+                checksum,
+                app_dic['parsed_xml'],
+                ns,
+                man_data_dic,
+                '',
+                app_dic['app_dir'])
+
+            mal_perms = permissions.check_malware_permission(
+                checksum,
+                man_data_dic['perm'])
+            man_an_dic['malware_permissions'] = mal_perms
+
+            get_icon_apk(apk, app_dic)
+
+            elf_dict = library_analysis(checksum, app_dic['app_dir'], 'elf')
+            cert_dic = cert_info(apk, app_dic, man_data_dic)
+            apkid_results = apkid.apkid_analysis(checksum, app_dic['app_path'])
+            tracker = Trackers.Trackers(checksum, app_dic['app_dir'], app_dic['tools_dir'])
+            tracker_res = tracker.get_trackers()
+            code_an_dic = code_analysis(checksum, app_dic['app_dir'], 'apk',
+                                        app_dic['manifest_file'], man_data_dic['perm'])
+            quark_results = quark.quark_analysis(checksum, app_dic['app_dir'], app_dic['app_path'])
+
+            get_strings_metadata(
+                checksum,
+                apk,
+                app_dic['app_dir'],
+                elf_dict['elf_strings'],
+                'apk',
+                ['.java'],
+                code_an_dic)
+
+            code_an_dic['firebase'] = firebase_analysis(checksum, code_an_dic['urls_list'])
+            code_an_dic['domains'] = MalwareDomainCheck().scan(checksum, code_an_dic['urls_list'])
+
+            app_dic['zipped'] = 'apk'
+            app_dic['playstore'] = app_dic.get('playstore', None)  # Initialize with None
+            context = save_get_ctx(
+                app_dic,
+                man_data_dic,
+                man_an_dic,
+                code_an_dic,
+                cert_dic,
+                elf_dict['elf_analysis'],
+                apkid_results,
+                quark_results,
+                tracker_res,
+                rescan,
+            )
+
+        context['appsec'] = get_android_dashboard(context, True)
+        context['average_cvss'] = get_avg_cvss(context['code_analysis'])
+        context['dynamic_analysis_done'] = is_file_exists(os.path.join(app_dic['app_dir'], 'logcat.txt'))
+
+        context['virus_total'] = None
+        if settings.VT_ENABLED:
+            vt = VirusTotal.VirusTotal(checksum)
+            context['virus_total'] = vt.get_result(app_dic['app_path'])
+
+        template = 'static_analysis/android_binary_analysis.html'
+        if api:
+            return context
+        else:
+            return render(request, template, context)
+
+    except KeyError as e:
+        errmsg = f"KeyError: {str(e)} - 'Attribute not found.'"
+        logger.error(errmsg)
+        append_scan_status(checksum, errmsg)
+        return print_n_send_error_response(request, errmsg, api, e)
+    except AttributeError as e:
+        errmsg = f"AttributeError: {str(e)} - 'Attribute not found.'"
+        logger.error(errmsg)
+        append_scan_status(checksum, errmsg)
+        return print_n_send_error_response(request, errmsg, api, e)
+    except Exception as exp:
+        errmsg = 'Error Performing Static Analysis'
+        logger.exception(errmsg)
+        exp = exp.__doc__
+        append_scan_status(checksum, errmsg, repr(exp))
+        return print_n_send_error_response(request, repr(exp), api)
+
+import json
+
+def save_app_dic_to_file(app_dic, checksum):
+    app_dic_serializable = {}
+    
+    for k, v in app_dic.items():
+        if isinstance(v, Path):
+            app_dic_serializable[k] = str(v)
+        elif isinstance(v, dict):
+            app_dic_serializable[k] = v
+        else:
+            try:
+                json.dumps(v)
+                app_dic_serializable[k] = v
+            except TypeError:
+                app_dic_serializable[k] = str(v)
+    
+    with open(f"{checksum}.dic", "w") as f:
+        json.dump(app_dic_serializable, f)
+
+def load_app_dic_from_file(checksum):
+    try:
+        with open(f"{checksum}.dic", "r") as f:
+            app_dic = json.load(f)
+            app_dic_deserialized = {}
+            for k, v in app_dic.items():
+                if 'path' in k.lower():
+                    app_dic_deserialized[k] = Path(v)
+                else:
+                    app_dic_deserialized[k] = v
+            return app_dic_deserialized
+    except FileNotFoundError:
+        return None
